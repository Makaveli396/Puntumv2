#!/usr/bin/env python3
import random
import sqlite3
import json
import asyncio
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from typing import Optional, Tuple, List, Dict, Any

# ========== CONSTANTES DE CONFIGURACI√ìN ==========
GAME_TIMEOUT_HOURS = 1
TRIVIA_TIME_LIMIT = 60  # segundos
TRIVIA_POINTS = 25
GUESS_MOVIE_BASE_POINTS = 30
GUESS_MOVIE_HINT_PENALTY = 5
EMOJI_MOVIE_POINTS = 20

# ========== MANEJO DE ERRORES Y LOGGING ==========
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def safe_db_operation(operation_name: str):
    """Decorador para operaciones seguras de BD"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            try:
                return await func(*args, **kwargs) if asyncio.iscoroutinefunction(func) else func(*args, **kwargs)
            except sqlite3.Error as e:
                logger.error(f"[ERROR] {operation_name}: {e}")
                return None
            except Exception as e:
                logger.error(f"[ERROR] Error inesperado en {operation_name}: {e}")
                return None
        return wrapper
    return decorator

# ========== BASE DE DATOS DE JUEGOS ==========

@safe_db_operation("crear tablas de juegos")
def create_games_tables():
    """Crear tablas para mini-juegos con mejor estructura"""
    conn = sqlite3.connect('bot_data.db')
    cursor = conn.cursor()
    
    # Tabla para estad√≠sticas de juegos - mejorada con √≠ndices
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS game_stats (
            user_id INTEGER,
            username TEXT,
            game_type TEXT,
            correct_answers INTEGER DEFAULT 0,
            total_attempts INTEGER DEFAULT 0,
            points_earned INTEGER DEFAULT 0,
            best_streak INTEGER DEFAULT 0,
            current_streak INTEGER DEFAULT 0,
            last_played TEXT,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (user_id, game_type)
        )
    ''')
    
    # A√±adir √≠ndices para mejor rendimiento
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_game_stats_user ON game_stats(user_id)')
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_game_stats_type ON game_stats(game_type)')
    
    # Tabla para sesiones activas - mejorada con m√°s informaci√≥n
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS active_games (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            chat_id INTEGER,
            user_id INTEGER,
            game_type TEXT,
            current_question TEXT,
            correct_answer TEXT,
            options TEXT,
            start_time TEXT,
            attempts INTEGER DEFAULT 0,
            hints_used INTEGER DEFAULT 0,
            max_hints INTEGER DEFAULT 0,
            points_available INTEGER DEFAULT 0,
            expires_at TEXT,
            created_at TEXT DEFAULT CURRENT_TIMESTAMP,
            UNIQUE(chat_id, user_id, game_type)
        )
    ''')
    
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_active_games_user ON active_games(chat_id, user_id)')
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_active_games_expires ON active_games(expires_at)')
    
    # Tabla para historial de partidas (opcional, para analytics)
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS game_history (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER,
            username TEXT,
            game_type TEXT,
            question TEXT,
            user_answer TEXT,
            correct_answer TEXT,
            is_correct BOOLEAN,
            points_earned INTEGER,
            hints_used INTEGER,
            time_taken INTEGER, -- en segundos
            played_at TEXT DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    conn.commit()
    conn.close()
    logger.info("üéÆ Tablas de mini-juegos creadas con optimizaciones")

# ========== DATOS DE JUEGOS (Mantenidos, pero con mejoras) ==========

class GameData:
    """Clase para manejar datos de juegos de forma m√°s organizada"""
    
    TRIVIA_QUESTIONS = [
        {
            "question": "¬øQui√©n dirigi√≥ 'Pulp Fiction' (1994)?",
            "options": ["A) Martin Scorsese", "B) Quentin Tarantino", "C) Francis Ford Coppola", "D) Stanley Kubrick"],
            "correct": "B",
            "explanation": "Quentin Tarantino dirigi√≥ esta obra maestra del cine independiente",
            "difficulty": "medium"
        },
        {
            "question": "¬øEn qu√© a√±o se estren√≥ 'El Padrino'?",
            "options": ["A) 1970", "B) 1971", "C) 1972", "D) 1973"],
            "correct": "C",
            "explanation": "El Padrino se estren√≥ en 1972 y gan√≥ 3 premios Oscar",
            "difficulty": "easy"
        },
        {
            "question": "¬øCu√°l es la pel√≠cula m√°s taquillera de todos los tiempos?",
            "options": ["A) Titanic", "B) Avatar (2009)", "C) Avengers: Endgame", "D) Star Wars: El despertar de la fuerza"],
            "correct": "B",
            "explanation": "Avatar (2009) recaud√≥ m√°s de $2.8 mil millones mundialmente",
            "difficulty": "medium"
        },
        {
            "question": "¬øQu√© actor interpret√≥ a Neo en 'The Matrix'?",
            "options": ["A) Will Smith", "B) Johnny Depp", "C) Keanu Reeves", "D) Leonardo DiCaprio"],
            "correct": "C",
            "explanation": "Keanu Reeves inmortaliz√≥ al personaje de Neo",
            "difficulty": "easy"
        },
        {
            "question": "¬øCu√°ntos Oscars gan√≥ 'El Se√±or de los Anillos: El Retorno del Rey'?",
            "options": ["A) 9", "B) 10", "C) 11", "D) 12"],
            "correct": "C",
            "explanation": "Gan√≥ 11 Oscars, r√©cord compartido con Ben-Hur y Titanic",
            "difficulty": "hard"
        },
        {
            "question": "¬øEn qu√© pel√≠cula aparece la frase 'Que la fuerza te acompa√±e'?",
            "options": ["A) Star Trek", "B) Star Wars", "C) Guardianes de la Galaxia", "D) Blade Runner"],
            "correct": "B",
            "explanation": "Esta ic√≥nica frase es de la saga Star Wars",
            "difficulty": "easy"
        },
        {
            "question": "¬øQui√©n compuso la m√∫sica de 'Tibur√≥n' (1975)?",
            "options": ["A) Hans Zimmer", "B) John Williams", "C) Danny Elfman", "D) Ennio Morricone"],
            "correct": "B",
            "explanation": "John Williams cre√≥ esa terror√≠fica y simple melod√≠a",
            "difficulty": "medium"
        },
        {
            "question": "¬øQu√© director es conocido por sus pel√≠culas de suspenso como 'Psicosis' y 'V√©rtigo'?",
            "options": ["A) Brian De Palma", "B) David Lynch", "C) Alfred Hitchcock", "D) Roman Polanski"],
            "correct": "C",
            "explanation": "Alfred Hitchcock, el maestro del suspenso",
            "difficulty": "medium"
        },
        {
            "question": "¬øQu√© pel√≠cula de 2010 gan√≥ el Oscar a Mejor Pel√≠cula?",
            "options": ["A) Inception", "B) The Social Network", "C) The King's Speech", "D) Black Swan"],
            "correct": "C",
            "explanation": "The King's Speech gan√≥ el Oscar a Mejor Pel√≠cula en 2011",
            "difficulty": "hard"
        },
        {
            "question": "¬øQui√©n interpret√≥ al Joker en 'The Dark Knight' (2008)?",
            "options": ["A) Jack Nicholson", "B) Heath Ledger", "C) Joaquin Phoenix", "D) Jared Leto"],
            "correct": "B",
            "explanation": "Heath Ledger dio una actuaci√≥n legendaria como el Joker",
            "difficulty": "medium"
        }
    ]
    
    MOVIE_PUZZLES = [
        {
            "hints": [
                "üîç Drama carcelario de 1994",
                "üîç Protagonistas: Tim Robbins y Morgan Freeman",
                "üîç Prisi√≥n de Shawshank",
                "üîç 'Get busy living or get busy dying'"
            ],
            "answer": ["shawshank", "sue√±os de fuga", "cadena perpetua"],
            "title": "Sue√±os de Fuga (The Shawshank Redemption)",
            "difficulty": "medium"
        },
        {
            "hints": [
                "üîç Ciencia ficci√≥n, 1999",
                "üîç Realidad virtual y p√≠ldoras",
                "üîç Neo, Morfeo, Trinity",
                "üîç '¬øP√≠ldora roja o azul?'"
            ],
            "answer": ["matrix", "the matrix"],
            "title": "The Matrix",
            "difficulty": "easy"
        },
        {
            "hints": [
                "üîç √âpica espacial, 1977",
                "üîç Luke Skywalker y la Princesa Leia",
                "üîç Darth Vader y la Estrella de la Muerte",
                "üîç 'Que la fuerza te acompa√±e'"
            ],
            "answer": ["star wars", "una nueva esperanza", "la guerra de las galaxias"],
            "title": "Star Wars: Una Nueva Esperanza",
            "difficulty": "easy"
        },
        {
            "hints": [
                "üîç Thriller psicol√≥gico, 1999",
                "üîç Brad Pitt y Edward Norton",
                "üîç Reglas que no se pueden mencionar",
                "üîç 'Su nombre era Robert Paulson'"
            ],
            "answer": ["fight club", "el club de la pelea", "club de la pelea"],
            "title": "Fight Club",
            "difficulty": "hard"
        },
        {
            "hints": [
                "üîç Romance √©pico, 1997",
                "üîç Leonardo DiCaprio y Kate Winslet",
                "üîç Barco que se hunde",
                "üîç 'I'm the king of the world!'"
            ],
            "answer": ["titanic"],
            "title": "Titanic",
            "difficulty": "easy"
        },
        {
            "hints": [
                "üîç Animaci√≥n de Pixar, 1995",
                "üîç Woody y Buzz Lightyear",
                "üîç Juguetes que cobran vida",
                "üîç 'To infinity and beyond!'"
            ],
            "answer": ["toy story", "toy story 1"],
            "title": "Toy Story",
            "difficulty": "easy"
        }
    ]
    
    EMOJI_MOVIES = [
        {
            "emojis": "ü¶Åüëëüåç",
            "answer": ["el rey leon", "rey leon", "the lion king", "lion king"],
            "title": "El Rey Le√≥n",
            "difficulty": "easy"
        },
        {
            "emojis": "üö¢üíïüßä",
            "answer": ["titanic"],
            "title": "Titanic",
            "difficulty": "easy"
        },
        {
            "emojis": "üï∑Ô∏èüë®üèª‚Äçüéìüè¢",
            "answer": ["spiderman", "spider-man", "hombre ara√±a"],
            "title": "Spider-Man",
            "difficulty": "easy"
        },
        {
            "emojis": "ü§ñüöóüåç",
            "answer": ["transformers"],
            "title": "Transformers",
            "difficulty": "medium"
        },
        {
            "emojis": "üç´üè≠üë∂",
            "answer": ["charlie y la fabrica de chocolate", "charlie fabrica chocolate", "willy wonka"],
            "title": "Charlie y la F√°brica de Chocolate",
            "difficulty": "medium"
        },
        {
            "emojis": "ü¶áüåÉüÉè",
            "answer": ["batman", "el caballero de la noche", "dark knight"],
            "title": "Batman / El Caballero de la Noche",
            "difficulty": "medium"
        },
        {
            "emojis": "üßô‚Äç‚ôÇÔ∏è‚ö°üí´",
            "answer": ["harry potter"],
            "title": "Harry Potter",
            "difficulty": "easy"
        },
        {
            "emojis": "üê†üêüüåä",
            "answer": ["finding nemo", "buscando a nemo", "nemo"],
            "title": "Buscando a Nemo",
            "difficulty": "easy"
        },
        {
            "emojis": "üíçüëë‚öîÔ∏è",
            "answer": ["lord of the rings", "se√±or de los anillos", "lotr"],
            "title": "El Se√±or de los Anillos",
            "difficulty": "medium"
        },
        {
            "emojis": "üëªüö´‚òéÔ∏è",
            "answer": ["ghostbusters", "cazafantasmas"],
            "title": "Cazafantasmas",
            "difficulty": "medium"
        }
    ]

# ========== FUNCIONES DE JUEGO OPTIMIZADAS ==========

class GameManager:
    """Clase para manejar la l√≥gica de juegos de forma m√°s organizada"""
    
    @staticmethod
    @safe_db_operation("guardar estad√≠sticas de juego")
    def save_game_stats(user_id: int, username: str, game_type: str, correct: bool, points: int) -> bool:
        """Guardar estad√≠sticas del juego con manejo mejorado de rachas"""
        conn = sqlite3.connect('bot_data.db')
        cursor = conn.cursor()
        
        # Obtener estad√≠sticas actuales
        cursor.execute('''
            SELECT current_streak, best_streak FROM game_stats 
            WHERE user_id = ? AND game_type = ?
        ''', (user_id, game_type))
        
        result = cursor.fetchone()
        current_streak = result[0] if result else 0
        best_streak = result[1] if result else 0
        
        # Calcular nueva racha
        if correct:
            new_streak = current_streak + 1
            new_best = max(best_streak, new_streak)
        else:
            new_streak = 0
            new_best = best_streak
        
        # Actualizar o insertar estad√≠sticas
        cursor.execute('''
            INSERT OR REPLACE INTO game_stats (
                user_id, username, game_type, correct_answers, total_attempts, 
                points_earned, current_streak, best_streak, last_played, updated_at
            )
            VALUES (?, ?, ?, 
                COALESCE((SELECT correct_answers FROM game_stats WHERE user_id = ? AND game_type = ?), 0) + ?,
                COALESCE((SELECT total_attempts FROM game_stats WHERE user_id = ? AND game_type = ?), 0) + 1,
                COALESCE((SELECT points_earned FROM game_stats WHERE user_id = ? AND game_type = ?), 0) + ?,
                ?, ?, ?, ?
            )
        ''', (user_id, username, game_type, user_id, game_type, 1 if correct else 0, 
              user_id, game_type, user_id, game_type, points, new_streak, new_best,
              datetime.now().isoformat(), datetime.now().isoformat()))
        
        conn.commit()
        conn.close()
        return True
    
    @staticmethod
    @safe_db_operation("iniciar juego activo")
    def start_active_game(chat_id: int, user_id: int, game_type: str, question: str, 
                         answer: str, options: str = "", max_hints: int = 0, points: int = 0) -> bool:
        """Iniciar una sesi√≥n de juego activa con mejores controles"""
        conn = sqlite3.connect('bot_data.db')
        cursor = conn.cursor()
        
        expires_at = datetime.now() + timedelta(hours=GAME_TIMEOUT_HOURS)
        
        cursor.execute('''
            INSERT OR REPLACE INTO active_games 
            (chat_id, user_id, game_type, current_question, correct_answer, options, 
             start_time, attempts, hints_used, max_hints, points_available, expires_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, 0, 0, ?, ?, ?)
        ''', (chat_id, user_id, game_type, question, answer, options, 
              datetime.now().isoformat(), max_hints, points, expires_at.isoformat()))
        
        conn.commit()
        conn.close()
        return True
    
    @staticmethod
    @safe_db_operation("obtener juego activo")
    def get_active_game(chat_id: int, user_id: int, game_type: str) -> Optional[Tuple]:
        """Obtener juego activo con validaci√≥n de expiraci√≥n"""
        conn = sqlite3.connect('bot_data.db')
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT current_question, correct_answer, options, attempts, hints_used, 
                   max_hints, points_available, expires_at
            FROM active_games 
            WHERE chat_id = ? AND user_id = ? AND game_type = ? AND expires_at > ?
        ''', (chat_id, user_id, game_type, datetime.now().isoformat()))
        
        result = cursor.fetchone()
        conn.close()
        return result
    
    @staticmethod
    @safe_db_operation("terminar juego activo")
    def end_active_game(chat_id: int, user_id: int, game_type: str) -> bool:
        """Terminar juego activo"""
        conn = sqlite3.connect('bot_data.db')
        cursor = conn.cursor()
        
        cursor.execute('DELETE FROM active_games WHERE chat_id = ? AND user_id = ? AND game_type = ?', 
                       (chat_id, user_id, game_type))
        
        conn.commit()
        conn.close()
        return True
    
    @staticmethod
    @safe_db_operation("actualizar intentos de juego")
    def update_game_attempts(chat_id: int, user_id: int, game_type: str, increment_hints: bool = False) -> bool:
        """Actualizar intentos y pistas usadas"""
        conn = sqlite3.connect('bot_data.db')
        cursor = conn.cursor()
        
        if increment_hints:
            cursor.execute('''
                UPDATE active_games SET attempts = attempts + 1, hints_used = hints_used + 1
                WHERE chat_id = ? AND user_id = ? AND game_type = ?
            ''', (chat_id, user_id, game_type))
        else:
            cursor.execute('''
                UPDATE active_games SET attempts = attempts + 1
                WHERE chat_id = ? AND user_id = ? AND game_type = ?
            ''', (chat_id, user_id, game_type))
        
        conn.commit()
        conn.close()
        return True
    
    @staticmethod
    @safe_db_operation("limpiar juegos expirados")
    def cleanup_expired_games() -> int:
        """Limpiar juegos expirados de forma m√°s eficiente"""
        conn = sqlite3.connect('bot_data.db')
        cursor = conn.cursor()
        
        cursor.execute('DELETE FROM active_games WHERE expires_at < ?', 
                       (datetime.now().isoformat(),))
        
        deleted = cursor.rowcount
        conn.commit()
        conn.close()
        
        if deleted > 0:
            logger.info(f"üßπ Limpiados {deleted} juegos expirados")
        
        return deleted
    
    @staticmethod
    def normalize_answer(answer: str) -> str:
        """Normalizar respuesta para comparaci√≥n m√°s flexible"""
        import unicodedata
        import re
        
        # Convertir a min√∫sculas
        answer = answer.lower()
        
        # Eliminar acentos
        answer = ''.join(c for c in unicodedata.normalize('NFD', answer)
                        if unicodedata.category(c) != 'Mn')
        
        # Eliminar caracteres especiales y espacios extra
        answer = re.sub(r'[^\w\s]', '', answer)
        answer = ' '.join(answer.split())
        
        return answer

# ========== COMANDOS DE MINI-JUEGOS MEJORADOS ==========

async def cmd_cinematrivia(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /cinematrivia - Trivia cinematogr√°fica mejorada"""
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name or "Usuario"
    chat_id = update.effective_chat.id
    
    # Verificar si ya hay un juego activo
    active_game = GameManager.get_active_game(chat_id, user_id, 'trivia')
    if active_game:
        await update.message.reply_text(
            "üéÆ **¬°Ya tienes una trivia activa!**\n\n"
            "Responde la pregunta actual o usa `/rendirse` para terminar el juego",
            parse_mode='Markdown'
        )
        return
    
    # Seleccionar pregunta aleatoria
    question_data = random.choice(GameData.TRIVIA_QUESTIONS)
    
    # Crear botones de respuesta con callback data √∫nico
    keyboard = []
    session_id = f"{chat_id}_{user_id}_{int(datetime.now().timestamp())}"
    for i, option in enumerate(question_data["options"]):
        option_letter = chr(65+i)  # A, B, C, D
        callback_data = f"trivia_{question_data['correct']}_{option_letter}_{session_id}"
        keyboard.append([InlineKeyboardButton(option, callback_data=callback_data)])
    
    # A√±adir bot√≥n de rendirse
    keyboard.append([InlineKeyboardButton("üè≥Ô∏è Rendirse", callback_data=f"surrender_trivia_{session_id}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Guardar juego activo
    GameManager.start_active_game(
        chat_id, user_id, 'trivia',
        question_data["question"],
        question_data["correct"],
        json.dumps(question_data),  # Guardar toda la data como JSON
        max_hints=0,
        points=TRIVIA_POINTS
    )
    
    # Enviar pregunta
    difficulty_emoji = {"easy": "üü¢", "medium": "üü°", "hard": "üî¥"}.get(question_data.get("difficulty", "medium"), "üü°")
    
    trivia_text = (
        f"üé¨ **CINE-TRIVIA** üçø\n\n"
        f"üë§ **Jugador:** {username}\n"
        f"{difficulty_emoji} **Dificultad:** {question_data.get('difficulty', 'medium').title()}\n\n"
        f"‚ùì **{question_data['question']}**\n\n"
        f"‚è∞ **Tienes {TRIVIA_TIME_LIMIT} segundos para responder**\n"
        f"üèÜ **+{TRIVIA_POINTS} puntos** si aciertas"
    )
    
    await update.message.reply_text(trivia_text, reply_markup=reply_markup, parse_mode='Markdown')

async def cmd_adivinapelicula(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /adivinapelicula - Adivinar pel√≠cula con pistas mejorado"""
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name or "Usuario"
    chat_id = update.effective_chat.id
    
    # Verificar juego activo
    active_game = GameManager.get_active_game(chat_id, user_id, 'guess_movie')
    if active_game:
        await update.message.reply_text(
            "üéÆ **¬°Ya tienes un juego de adivinanza activo!**\n\n"
            "Escribe tu respuesta o usa `/rendirse` para terminar",
            parse_mode='Markdown'
        )
        return
    
    # Seleccionar pel√≠cula aleatoria
    movie_data = random.choice(GameData.MOVIE_PUZZLES)
    
    # Guardar juego activo
    GameManager.start_active_game(
        chat_id, user_id, 'guess_movie',
        movie_data["title"],
        json.dumps(movie_data["answer"]),  # M√∫ltiples respuestas v√°lidas
        json.dumps(movie_data),  # Toda la data
        max_hints=len(movie_data["hints"]) - 1,
        points=GUESS_MOVIE_BASE_POINTS
    )
    
    # Enviar primera pista
    difficulty_emoji = {"easy": "üü¢", "medium": "üü°", "hard": "üî¥"}.get(movie_data.get("difficulty", "medium"), "üü°")
    
    guess_text = (
        f"üîç **ADIVINA LA PEL√çCULA** üé¨\n\n"
        f"üë§ **Jugador:** {username}\n"
        f"{difficulty_emoji} **Dificultad:** {movie_data.get('difficulty', 'medium').title()}\n\n"
        f"{movie_data['hints'][0]}\n\n"
        f"üí° **Escribe el t√≠tulo de la pel√≠cula**\n"
        f"üéØ **+{GUESS_MOVIE_BASE_POINTS} puntos** (m√°ximo)\n"
        f"üìù **Comandos:** `/pista` para m√°s ayuda, `/rendirse` para terminar"
    )
    
    await update.message.reply_text(guess_text, parse_mode='Markdown')

async def cmd_emojipelicula(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /emojipelicula - Adivinar pel√≠cula por emojis mejorado"""
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name or "Usuario"
    chat_id = update.effective_chat.id
    
    # Verificar juego activo
    active_game = GameManager.get_active_game(chat_id, user_id, 'emoji_movie')
    if active_game:
        await update.message.reply_text(
            "üéÆ **¬°Ya tienes un juego de emojis activo!**\n\n"
            "Adivina la pel√≠cula actual o usa `/rendirse`",
            parse_mode='Markdown'
        )
        return
    
    # Seleccionar pel√≠cula aleatoria
    emoji_data = random.choice(GameData.EMOJI_MOVIES)
    
    # Guardar juego activo
    GameManager.start_active_game(
        chat_id, user_id, 'emoji_movie',
        emoji_data["emojis"],
        json.dumps(emoji_data["answer"]),
        json.dumps(emoji_data),
        max_hints=1,  # Solo una pista: el t√≠tulo exacto
        points=EMOJI_MOVIE_POINTS
    )
    
    # Enviar emojis
    difficulty_emoji = {"easy": "üü¢", "medium": "üü°", "hard": "üî¥"}.get(emoji_data.get("difficulty", "easy"), "üü¢")
    
    emoji_text = (
        f"üé≠ **PEL√çCULA EN EMOJIS** üé¨\n\n"
        f"üë§ **Jugador:** {username}\n"
        f"{difficulty_emoji} **Dificultad:** {emoji_data.get('difficulty', 'easy').title()}\n\n"
        f"üéØ **Adivina esta pel√≠cula:**\n\n"
        f"# {emoji_data['emojis']}\n\n"
        f"üí° **Escribe el t√≠tulo**\n"
        f"üèÜ **+{EMOJI_MOVIE_POINTS} puntos** por respuesta correcta\n"
        f"üìù **Usa** `/pista` **para obtener una pista o** `/rendirse` **para terminar**"
    )
    
    await update.message.reply_text(emoji_text, parse_mode='Markdown')

async def cmd_pista(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /pista - Pedir pista adicional mejorado"""
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id
    
    # Verificar juegos activos de adivinanza
    active_guess = GameManager.get_active_game(chat_id, user_id, 'guess_movie')
    active_emoji = GameManager.get_active_game(chat_id, user_id, 'emoji_movie')
    
    if not active_guess and not active_emoji:
        await update.message.reply_text("‚ùå No tienes un juego de adivinanza activo")
        return
    
    # Determinar tipo de juego
    if active_guess:
        game_type = 'guess_movie'
        active_game = active_guess
    else:
        game_type = 'emoji_movie'
        active_game = active_emoji

# Extraer datos del juego activo
    current_question, correct_answer, options, attempts, hints_used, max_hints, points_available, expires_at = active_game
    
    # Verificar si ya us√≥ todas las pistas
    if hints_used >= max_hints:
        await update.message.reply_text("‚ùå Ya has usado todas las pistas disponibles")
        return
    
    # Cargar datos del juego
    try:
        game_data = json.loads(options)
    except:
        await update.message.reply_text("‚ùå Error al cargar datos del juego")
        return
    
    # Actualizar intentos y pistas
    GameManager.update_game_attempts(chat_id, user_id, game_type, increment_hints=True)
    
    if game_type == 'guess_movie':
        # Mostrar siguiente pista
        next_hint_index = hints_used + 1
        if next_hint_index < len(game_data["hints"]):
            hint = game_data["hints"][next_hint_index]
            remaining_hints = max_hints - (hints_used + 1)
            penalty = GUESS_MOVIE_HINT_PENALTY * (hints_used + 1)
            current_points = max(5, points_available - penalty)
            
            hint_text = (
                f"üí° **PISTA ADICIONAL** ({hints_used + 1}/{max_hints})\n\n"
                f"{hint}\n\n"
                f"üèÜ **Puntos actuales:** {current_points}\n"
                f"üíî **Penalizaci√≥n por pista:** -{GUESS_MOVIE_HINT_PENALTY} puntos\n"
                f"üìù **Pistas restantes:** {remaining_hints}"
            )
        else:
            hint_text = f"‚ùå No hay m√°s pistas disponibles"
    
    elif game_type == 'emoji_movie':
        # Para emoji, la pista es el t√≠tulo exacto
        hint_text = (
            f"üí° **PISTA ESPECIAL**\n\n"
            f"üé¨ **T√≠tulo exacto:** {game_data['title']}\n\n"
            f"¬°Ahora deber√≠a ser m√°s f√°cil! üòâ"
        )
    
    await update.message.reply_text(hint_text, parse_mode='Markdown')

async def cmd_rendirse(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /rendirse - Rendirse en juego actual mejorado"""
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name or "Usuario"
    chat_id = update.effective_chat.id
    
    # Buscar juego activo
    active_games = []
    for game_type in ['trivia', 'guess_movie', 'emoji_movie']:
        game = GameManager.get_active_game(chat_id, user_id, game_type)
        if game:
            active_games.append((game_type, game))
    
    if not active_games:
        await update.message.reply_text("‚ùå No tienes ning√∫n juego activo")
        return
    
    # Procesar rendici√≥n para cada juego activo
    for game_type, game_data in active_games:
        current_question, correct_answer, options, attempts, hints_used, max_hints, points_available, expires_at = game_data
        
        # Registrar estad√≠sticas (intento fallido)
        GameManager.save_game_stats(user_id, username, game_type, False, 0)
        
        # Terminar juego
        GameManager.end_active_game(chat_id, user_id, game_type)
        
        # Mostrar respuesta correcta
        try:
            if game_type == 'trivia':
                game_info = json.loads(options)
                correct_option = next(opt for opt in game_info["options"] if opt.startswith(f"{correct_answer})"))
                answer_text = f"‚úÖ **Respuesta correcta:** {correct_option}\nüìö {game_info.get('explanation', '')}"
            else:
                possible_answers = json.loads(correct_answer)
                answer_text = f"‚úÖ **Respuesta correcta:** {possible_answers[0].title()}"
        except:
            answer_text = "‚úÖ **Respuesta revelada**"
        
        surrender_text = (
            f"üè≥Ô∏è **Te has rendido en {game_type.replace('_', ' ').title()}**\n\n"
            f"{answer_text}\n\n"
            f"üí™ **¬°No te rindas! Int√©ntalo de nuevo cuando quieras**"
        )
        
        await update.message.reply_text(surrender_text, parse_mode='Markdown')

async def cmd_estadisticas_juegos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /estadisticasjuegos - Ver estad√≠sticas personales mejoradas"""
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name or "Usuario"
    
    conn = sqlite3.connect('bot_data.db')
    cursor = conn.cursor()
    
    # Obtener estad√≠sticas por tipo de juego
    cursor.execute('''
        SELECT game_type, correct_answers, total_attempts, points_earned, 
               current_streak, best_streak, last_played
        FROM game_stats WHERE user_id = ?
        ORDER BY points_earned DESC
    ''', (user_id,))
    
    stats = cursor.fetchall()
    conn.close()
    
    if not stats:
        await update.message.reply_text(
            f"üìä **Estad√≠sticas de {username}**\n\n"
            "üéÆ ¬°A√∫n no has jugado ning√∫n mini-juego!\n\n"
            "**Comandos disponibles:**\n"
            "‚Ä¢ `/cinematrivia` - Trivia cinematogr√°fica\n"
            "‚Ä¢ `/adivinapelicula` - Adivinar por pistas\n"
            "‚Ä¢ `/emojipelicula` - Adivinar por emojis"
        )
        return
    
    # Calcular totales
    total_points = sum(stat[3] for stat in stats)
    total_correct = sum(stat[1] for stat in stats)
    total_attempts = sum(stat[2] for stat in stats)
    overall_accuracy = (total_correct / total_attempts * 100) if total_attempts > 0 else 0
    
    stats_text = f"üìä **Estad√≠sticas de {username}**\n\n"
    
    # Estad√≠sticas generales
    stats_text += (
        f"üéØ **RESUMEN GENERAL**\n"
        f"üèÜ **Puntos totales:** {total_points:,}\n"
        f"‚úÖ **Aciertos:** {total_correct}/{total_attempts}\n"
        f"üìà **Precisi√≥n:** {overall_accuracy:.1f}%\n\n"
    )
    
    # Estad√≠sticas por juego
    game_names = {
        'trivia': 'üé¨ Cine-Trivia',
        'guess_movie': 'üîç Adivina Pel√≠cula',
        'emoji_movie': 'üé≠ Emoji Pel√≠cula'
    }
    
    stats_text += "üìã **POR TIPO DE JUEGO**\n\n"
    
    for game_type, correct, attempts, points, current_streak, best_streak, last_played in stats:
        game_name = game_names.get(game_type, game_type.title())
        accuracy = (correct / attempts * 100) if attempts > 0 else 0
        
        # Formatear √∫ltima vez jugado
        try:
            last_date = datetime.fromisoformat(last_played)
            last_formatted = last_date.strftime("%d/%m/%Y")
        except:
            last_formatted = "N/A"
        
        stats_text += (
            f"{game_name}\n"
            f"  üéØ {correct}/{attempts} ({accuracy:.1f}%)\n"
            f"  üèÜ {points:,} puntos\n"
            f"  üî• Racha: {current_streak} (mejor: {best_streak})\n"
            f"  üìÖ √öltimo: {last_formatted}\n\n"
        )
    
    # Ranking personal (gamificaci√≥n)
    if total_points >= 1000:
        rank = "üèÜ Maestro del Cine"
    elif total_points >= 500:
        rank = "ü•á Experto Cinematogr√°fico"
    elif total_points >= 200:
        rank = "ü•à Cin√©filo Avanzado"
    elif total_points >= 50:
        rank = "ü•â Aficionado al Cine"
    else:
        rank = "üé¨ Principiante"
    
    stats_text += f"üéñÔ∏è **Rango actual:** {rank}"
    
    await update.message.reply_text(stats_text, parse_mode='Markdown')

async def cmd_top_jugadores(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /topjugadores - Ranking global de jugadores"""
    conn = sqlite3.connect('bot_data.db')
    cursor = conn.cursor()
    
    # Obtener top jugadores por puntos totales
    cursor.execute('''
        SELECT username, SUM(points_earned) as total_points, 
               SUM(correct_answers) as total_correct,
               SUM(total_attempts) as total_attempts,
               MAX(best_streak) as best_streak
        FROM game_stats 
        GROUP BY user_id, username
        HAVING total_points > 0
        ORDER BY total_points DESC
        LIMIT 10
    ''', ())
    
    top_players = cursor.fetchall()
    conn.close()
    
    if not top_players:
        await update.message.reply_text("üìä **Top Jugadores**\n\nüéÆ ¬°A√∫n no hay jugadores en el ranking!")
        return
    
    ranking_text = "üèÜ **TOP 10 JUGADORES** üé¨\n\n"
    
    medals = ["ü•á", "ü•à", "ü•â"] + ["üèÖ"] * 7
    
    for i, (username, points, correct, attempts, best_streak) in enumerate(top_players):
        position = i + 1
        medal = medals[i]
        accuracy = (correct / attempts * 100) if attempts > 0 else 0
        
        ranking_text += (
            f"{medal} **#{position} {username}**\n"
            f"    üèÜ {points:,} puntos\n"
            f"    üéØ {accuracy:.1f}% precisi√≥n\n"
            f"    üî• Mejor racha: {best_streak}\n\n"
        )
    
    await update.message.reply_text(ranking_text, parse_mode='Markdown')

# ========== MANEJADORES DE CALLBACKS MEJORADOS ==========

async def handle_trivia_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manejar respuestas de trivia con mejores validaciones"""
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    username = query.from_user.username or query.from_user.first_name or "Usuario"
    chat_id = query.message.chat_id
    
    # Parsear callback data
    try:
        parts = query.data.split('_')
        if parts[0] == "surrender" and parts[1] == "trivia":
            # Manejar rendici√≥n desde bot√≥n
            active_game = GameManager.get_active_game(chat_id, user_id, 'trivia')
            if active_game:
                GameManager.save_game_stats(user_id, username, 'trivia', False, 0)
                GameManager.end_active_game(chat_id, user_id, 'trivia')
                
                try:
                    game_info = json.loads(active_game[2])  # options field
                    correct_answer = active_game[1]  # correct_answer field
                    correct_option = next(opt for opt in game_info["options"] if opt.startswith(f"{correct_answer})"))
                    explanation = game_info.get('explanation', '')
                    
                    surrender_text = (
                        f"üè≥Ô∏è **Te has rendido**\n\n"
                        f"‚úÖ **Respuesta correcta:** {correct_option}\n"
                        f"üìö {explanation}\n\n"
                        f"üí™ **¬°Int√©ntalo de nuevo!**"
                    )
                except:
                    surrender_text = "üè≥Ô∏è **Te has rendido**\n\nüí™ **¬°Int√©ntalo de nuevo!**"
                
                await query.edit_message_text(surrender_text, parse_mode='Markdown')
            return
        
        # Respuesta normal
        if len(parts) < 4:
            return
            
        _, correct_answer, user_answer, session_id = parts
        
    except (IndexError, ValueError):
        await query.edit_message_text("‚ùå Error al procesar respuesta")
        return
    
    # Verificar juego activo
    active_game = GameManager.get_active_game(chat_id, user_id, 'trivia')
    if not active_game:
        await query.edit_message_text("‚ùå Este juego ya no est√° activo")
        return
    
    # Validar sesi√≥n (anti-trampa b√°sico)
    expected_session = f"{chat_id}_{user_id}"
    if not session_id.startswith(expected_session):
        await query.edit_message_text("‚ùå Sesi√≥n inv√°lida")
        return
    
    # Verificar respuesta
    is_correct = user_answer == correct_answer
    
    # Cargar datos de la pregunta
    try:
        question_data = json.loads(active_game[2])  # options field
        explanation = question_data.get('explanation', '')
        difficulty = question_data.get('difficulty', 'medium')
    except:
        explanation = ""
        difficulty = 'medium'
    
    # Calcular puntos (bonus por dificultad)
    points = TRIVIA_POINTS
    if is_correct:
        if difficulty == 'hard':
            points += 10
        elif difficulty == 'easy':
            points -= 5
        points = max(5, points)
    else:
        points = 0
    
    # Guardar estad√≠sticas
    GameManager.save_game_stats(user_id, username, 'trivia', is_correct, points)
    
    # Terminar juego
    GameManager.end_active_game(chat_id, user_id, 'trivia')
    
    # Preparar respuesta
    if is_correct:
        result_emoji = "üéâ"
        result_text = "¬°CORRECTO!"
        color_emoji = "üü¢"
    else:
        result_emoji = "‚ùå"
        result_text = "INCORRECTO"
        color_emoji = "üî¥"
    
    # Obtener respuesta correcta formateada
    try:
        correct_option = next(opt for opt in question_data["options"] if opt.startswith(f"{correct_answer})"))
    except:
        correct_option = f"Opci√≥n {correct_answer}"
    
    response_text = (
        f"{result_emoji} **{result_text}**\n\n"
        f"‚úÖ **Respuesta correcta:** {correct_option}\n"
    )
    
    if explanation:
        response_text += f"üìö **Explicaci√≥n:** {explanation}\n"
    
    response_text += (
        f"\nüèÜ **Puntos obtenidos:** +{points}\n"
        f"{color_emoji} **Dificultad:** {difficulty.title()}"
    )
    
    if is_correct:
        response_text += "\n\nüé¨ **¬°Sigue as√≠, cin√©filo!**"
    else:
        response_text += "\n\nüí™ **¬°La pr√≥xima ser√°!**"
    
    await query.edit_message_text(response_text, parse_mode='Markdown')

async def handle_game_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Manejar respuestas de texto para juegos de adivinanza mejorado"""
    if not update.message or not update.message.text:
        return
    
    user_id = update.effective_user.id
    username = update.effective_user.username or update.effective_user.first_name or "Usuario"
    chat_id = update.effective_chat.id
    user_answer = update.message.text.strip()
    
    # Verificar juegos activos de adivinanza
    guess_game = GameManager.get_active_game(chat_id, user_id, 'guess_movie')
    emoji_game = GameManager.get_active_game(chat_id, user_id, 'emoji_movie')
    
    if not guess_game and not emoji_game:
        return  # No hay juegos activos, no hacer nada
    
    # Determinar tipo de juego
    if guess_game:
        game_type = 'guess_movie'
        active_game = guess_game
        base_points = GUESS_MOVIE_BASE_POINTS
        penalty_per_hint = GUESS_MOVIE_HINT_PENALTY
    else:
        game_type = 'emoji_movie'
        active_game = emoji_game
        base_points = EMOJI_MOVIE_POINTS
        penalty_per_hint = 0  # Sin penalizaci√≥n por pistas en emoji
    
    # Extraer datos del juego
    current_question, correct_answers_json, options, attempts, hints_used, max_hints, points_available, expires_at = active_game
    
    try:
        correct_answers = json.loads(correct_answers_json)
        game_data = json.loads(options)
    except:
        await update.message.reply_text("‚ùå Error al cargar datos del juego")
        return
    
    # Normalizar respuestas para comparaci√≥n
    normalized_user_answer = GameManager.normalize_answer(user_answer)
    normalized_correct_answers = [GameManager.normalize_answer(ans) for ans in correct_answers]
    
    # Verificar si la respuesta es correcta
    is_correct = any(normalized_user_answer in correct_ans or correct_ans in normalized_user_answer 
                    for correct_ans in normalized_correct_answers)
    
    # Calcular puntos
    if is_correct:
        penalty = penalty_per_hint * hints_used
        points = max(5, base_points - penalty)
    else:
        points = 0
    
    # Actualizar intentos
    GameManager.update_game_attempts(chat_id, user_id, game_type)
    
    # Guardar estad√≠sticas
    GameManager.save_game_stats(user_id, username, game_type, is_correct, points)
    
    # Terminar juego
    GameManager.end_active_game(chat_id, user_id, game_type)
    
    # Preparar respuesta
    if is_correct:
        result_emoji = "üéâ"
        result_text = "¬°CORRECTO!"
        
        bonus_text = ""
        if hints_used == 0:
            bonus_text = "\nüåü **¬°Perfecto sin pistas!**"
        elif hints_used == 1:
            bonus_text = "\nüëè **¬°Muy bien con solo una pista!**"
        
        response_text = (
            f"{result_emoji} **{result_text}**\n\n"
            f"üé¨ **Pel√≠cula:** {game_data['title']}\n"
            f"üí≠ **Tu respuesta:** {user_answer}\n"
            f"üèÜ **Puntos obtenidos:** +{points}\n"
            f"üí° **Pistas usadas:** {hints_used}/{max_hints}"
            f"{bonus_text}\n\n"
            f"üé≠ **¬°Excelente conocimiento cinematogr√°fico!**"
        )
    else:
        response_text = (
            f"‚ùå **INCORRECTO**\n\n"
            f"üé¨ **Pel√≠cula:** {game_data['title']}\n"
            f"üí≠ **Tu respuesta:** {user_answer}\n"
            f"‚úÖ **Respuestas v√°lidas:** {', '.join(correct_answers[:3])}\n"
            f"üí° **Pistas usadas:** {hints_used}/{max_hints}\n\n"
            f"üí™ **¬°Sigue intentando, cada vez estar√°s m√°s cerca!**"
        )
    
    await update.message.reply_text(response_text, parse_mode='Markdown')

# ========== INICIALIZACI√ìN Y LIMPIEZA AUTOM√ÅTICA ==========

async def cleanup_games_periodically():
    """Limpiar juegos expirados peri√≥dicamente"""
    while True:
        try:
            GameManager.cleanup_expired_games()
            await asyncio.sleep(3600)  # Cada hora
        except Exception as e:
            logger.error(f"Error en limpieza autom√°tica: {e}")
            await asyncio.sleep(3600)

def initialize_games_system():
    """Inicializar el sistema de mini-juegos"""
    try:
        create_games_tables()
        logger.info("üéÆ Sistema de mini-juegos inicializado correctamente")
        return True
    except Exception as e:
        logger.error(f"Error al inicializar sistema de juegos: {e}")
        return False

# ========== COMANDOS ADICIONALES DE UTILIDAD ==========

async def cmd_limpiar_juegos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando para limpiar juegos activos del usuario (√∫til para debugging)"""
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id
    
    # Limpiar todos los juegos activos del usuario
    games_cleared = 0
    for game_type in ['trivia', 'guess_movie', 'emoji_movie']:
        if GameManager.end_active_game(chat_id, user_id, game_type):
            games_cleared += 1
    
    if games_cleared > 0:
        await update.message.reply_text(
            f"üßπ **Limpieza completada**\n\n"
            f"Se terminaron {games_cleared} juego(s) activo(s)\n"
            f"Ya puedes iniciar nuevos juegos"
        )
    else:
        await update.message.reply_text("‚ú® No tienes juegos activos para limpiar")

async def cmd_ayuda_juegos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando de ayuda espec√≠fico para mini-juegos"""
    help_text = (
        "üéÆ **GU√çA DE MINI-JUEGOS** üé¨\n\n"
        
        "**üéØ CINE-TRIVIA**\n"
        "‚Ä¢ Comando: `/cinematrivia`\n"
        "‚Ä¢ Responde preguntas de cine\n"
        "‚Ä¢ +25 puntos base (+bonus por dificultad)\n"
        "‚Ä¢ 60 segundos para responder\n\n"
        
        "**üîç ADIVINA LA PEL√çCULA**\n"
        "‚Ä¢ Comando: `/adivinapelicula`\n"
        "‚Ä¢ Adivina por pistas progresivas\n"
        "‚Ä¢ +30 puntos base (-5 por cada pista)\n"
        "‚Ä¢ Usa `/pista` para m√°s ayuda\n\n"
        
        "**üé≠ PEL√çCULA EN EMOJIS**\n"
        "‚Ä¢ Comando: `/emojipelicula`\n"
        "‚Ä¢ Interpreta emojis para adivinar\n"
        "‚Ä¢ +20 puntos por respuesta correcta\n"
        "‚Ä¢ `/pista` revela el t√≠tulo exacto\n\n"
        
        "**üìä COMANDOS √öTILES**\n"
        "‚Ä¢ `/estadisticasjuegos` - Tus estad√≠sticas\n"
        "‚Ä¢ `/topjugadores` - Ranking global\n"
        "‚Ä¢ `/pista` - Pedir ayuda en adivinanzas\n"
        "‚Ä¢ `/rendirse` - Terminar juego actual\n"
        "‚Ä¢ `/limpiarjuegos` - Limpiar juegos activos\n\n"
        
        "**üèÜ SISTEMA DE PUNTOS**\n"
        "‚Ä¢ Acumula puntos por respuestas correctas\n"
        "‚Ä¢ Mant√©n rachas para mejor ranking\n"
        "‚Ä¢ Dificultad afecta puntuaci√≥n\n"
        "‚Ä¢ Compite en el ranking global\n\n"
        
        "**üí° CONSEJOS**\n"
        "‚Ä¢ Solo puedes tener un juego activo por tipo\n"
        "‚Ä¢ Los juegos expiran en 1 hora\n"
        "‚Ä¢ Las pistas reducen puntos en adivinanzas\n"
        "‚Ä¢ ¬°Practica para mejorar tu ranking!"
    )
    
    await update.message.reply_text(help_text, parse_mode='Markdown')

# ========== EXPORTAR FUNCIONES PRINCIPALES ==========

# Funciones que deben ser importadas y registradas en el bot principal
GAME_COMMANDS = {
    'cinematrivia': cmd_cinematrivia,
    'adivinapelicula': cmd_adivinapelicula,  
    'emojipelicula': cmd_emojipelicula,
    'pista': cmd_pista,
    'rendirse': cmd_rendirse,
    'estadisticasjuegos': cmd_estadisticas_juegos,
    'topjugadores': cmd_top_jugadores,
    'limpiarjuegos': cmd_limpiar_juegos,
    'ayudajuegos': cmd_ayuda_juegos
}

GAME_HANDLERS = {
    'trivia_callback': handle_trivia_callback,
    'game_message': handle_game_message,
    'cleanup_periodic': cleanup_games_periodically
}

# Funci√≥n de inicializaci√≥n que debe llamarse al iniciar el bot
def setup_games_system():
    """Configurar el sistema completo de mini-juegos"""
    if initialize_games_system():
        logger.info("üéÆ ¬°Sistema de mini-juegos listo para usar!")
        return True
    else:
        logger.error("‚ùå Error al configurar sistema de mini-juegos")
        return False
